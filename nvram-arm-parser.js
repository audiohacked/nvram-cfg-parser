// Generated by IcedCoffeeScript 108.0.11
(function() {
  var NvramArmParser, fs;

  fs = require('fs');

  NvramArmParser = (function() {
    function NvramArmParser() {}

    NvramArmParser.error = function(e) {
      return console.error("error: " + e);
    };

    NvramArmParser.header = Buffer.from("HDR2");

    NvramArmParser.is = function(buf) {
      return buf.slice(0, 4).equals(this.header);
    };

    NvramArmParser.decode = function(buf, autocb) {
      var filelen, filelenptr, i, lastgarbage, rand, randptr, _i, _ref;
      if (!(buf instanceof Buffer)) {
        buf = fs.readFileSync(buf);
        if (!this.is(buf)) {
          autocb(this.error("header \"" + buf + "\" does not match expected NVRAM ARM cfg format -- aborting"));
          return;
        }
      }
      filelenptr = this.header.length;
      filelen = buf.readUIntBE(filelenptr, 3);
      randptr = filelenptr + 3;
      rand = buf[randptr];
      for (i = _i = 8, _ref = filelen + 7; 8 <= _ref ? _i <= _ref : _i >= _ref; i = 8 <= _ref ? ++_i : --_i) {
        if (buf[i] > (0xfd - 0x1)) {
          if (i === lastgarbage + 1) {
            autocb(buf.slice(0, +(i - 1) + 1 || 9e9));
            return;
          }
          buf[i] = 0x0;
          lastgarbage = i;
        } else {
          buf[i] = 0xff + rand - buf[i];
        }
      }
      autocb(buf);
      return;
    };

    NvramArmParser.get_rand = function() {
      return Math.round(Math.random() * 0xff);
    };

    NvramArmParser.encode = function(pairs, autocb) {
      var byte, count, filelen, filelenbuf, footer, header, i, pairsbuf, rand, _i, _j, _len, _len1;
      pairsbuf = Buffer.concat(pairs);
      count = pairsbuf.length;
      filelen = count + (1024 - count % 1024);
      while (true) {
        rand = this.get_rand() % 30;
        if (!((7 < rand && rand < 14))) {
          break;
        }
      }
      filelenbuf = Buffer.alloc(3);
      filelenbuf.writeUIntBE(filelen, 0, 3);
      header = Buffer.concat([this.header, filelenbuf, Buffer.from([rand])]);
      footer = Buffer.alloc(filelen - count);
      for (_i = 0, _len = footer.length; _i < _len; _i++) {
        i = footer[_i];
        footer[i] = 0xfd + this.get_rand() % 3;
      }
      for (i = _j = 0, _len1 = pairsbuf.length; _j < _len1; i = ++_j) {
        byte = pairsbuf[i];
        if (byte === 0x0) {
          pairsbuf[i] = 0xfd + this.get_rand() % 3;
        } else {
          pairsbuf[i] = 0xff - pairsbuf[i] + rand;
        }
      }
      autocb(Buffer.concat([header, pairsbuf, footer]));
      return;
    };

    return NvramArmParser;

  })();

  module.exports = NvramArmParser;

}).call(this);
